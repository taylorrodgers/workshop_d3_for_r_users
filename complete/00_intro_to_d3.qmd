---
title: "Intro to D3 Workshop"
subtitle: "For R Users"
author: "Taylor Rodgers"
format:
  html:
      css: styles.css
editor: visual
---

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
load(paste0(getwd(),"/data/lScripts.rda"))
load(paste0(getwd(),"/data/lGold.rda"))

lScripts$scripts <- str_remove(lScripts$scripts , "complete/")
lScripts$custom_css <- str_remove(lScripts$custom_css , "complete/")
```

## Introduction

This tutorial is for R users who want to learn D3 for R-related projects.

D3.js is, without a doubt, the hardest data viz development framework you could ever learn.

It requires knowledge of HTML, CSS, and JavaScript.

Integrating D3 into R Shiny or Quarto is another level of difficulty. It requires you to know a bit about R Shiny and Quarto ahead of time.

Thankfully, all these skills reinforce one another.

But what it lacks in ease-of-use, it more than makes up for in precision.

Some of the most advanced interactive data visualizations in the world use D3.js. It's also used to make more simpler data visualizations that need to be client-side rendered and adaptable to different screen sizes.

For that reason, the best users of D3.js are often news organizations.

## Required Knowledge

This course is for R users, but most R-related scripts will be provided to you to focus more on D3. It's also expected that you know some HTML and CSS. Just like R, those scripts will also be provided ahead of time to allow more focus on D3.

That said, you should at least conceptually know the following:

-   An HTML tag

-   A CSS class

-   JSON files

-   RStudio's interface

-   R Shiny

-   Quarto HTML documents

-   tidyverse package functions

JavaScript is helpful to know, but not required. Although D3.js is JavaScript, the syntax is similar enough to the `tidyverse` and other `R` functions that users will be able to start with D3.

## Required Packages

You'll also need to install the following packages before proceeding:

```{r, eval = FALSE}
install.packages("tidyverse")
install.packages("shiny")
install.packages("bslib")
install.packages("r2d3")
install.packages("devtools")

devtools::install_github("https://github.com/Free-State-Analytics/freeStateData")
```

::: callout-tip
## Book Recommendation

I strongly suggest *Eloquent JavaScript* to learn JavaScript in general. As an R user, you'll find JavaScript to be surprisingly similar, particularly when it comes to writing functions.
:::

## What This Tutorial Teaches?

This tutorial is for R-users who want to learn D3.js. D3.js works well in both Quarto and Shiny. The skills you learned in those tools serve as a useful on-ramp to D3.js.

This tutorial will focus exclusively on building the data visualization you see below, which is a good introduction to key concepts in D3, as well as understanding how to properly structure your R and D3.js scripts.

```{r, echo = FALSE}
r2d3::r2d3(
  script = lScripts$scripts,
  css = lScripts$custom_css,
  data = jsonlite::toJSON(lGold))
```

Equally imporant, this tutorial also teaches you how to think about modularization and file structure, so that you know how to set up your projects to use these visualizations.

I think one of the reason D3 is so overwhelming is that, unlike ggplot2, it requires modularization (i.e., smaller functions) to keep the code oragnizaed and easy to maintain. For that reason, I build that concept into the lesson.

*Building a D3 visualization is about as much work as building a Shiny application!*

::: callout-note
## D3 is frickin' cool!

D3 provides more opportunities to build smoething cool than any other data viz framework I know of.

It is largely teh domain of hobbyists, but those who really value creative fulfillment, it's a great skill to invest in. The biggest publications (WSJ, New York Times, etc.) heavily rely on D3 to present information in a novel and interactive way.

(show gif)
:::

## Teaching a Foundation

Don't think though that this doesn't build towards your larger goal of building more complex data visualizations, or exploring other data viz types. This tutorial teaches the key foundational concepts.

The primary ones relate to:

-   Margins

-   Range

-   Domain

-   Width

The secondary concept to learn is to write smaller functions to tackle each individual part of the data visualization. The one we're working on has X number. Nearly every single one relies on the margin, range, and domain to some degree. Most wouldn't work without them.

You can see how changing margin, range, and domain operates with this Shiny App.

This tutorial takes you through annotations, headers, and other aesthetic choices that often make D3 look more professional. Learning these little quarks will give you more options in making more advanced visuals.

::: callout-warning
## D3 is frickin' hard!

D3 is without a doubt the hardest programming framework I have ever learned.

It's also quite touchy. It doesn't do anything you didn't ask it to do, and that also means a lack of robust error messages.

Directory names, function names, parameters, etc. are all things that will cause your script to not render.

So be patient with yourself. I have sometimes spent hours searching for an issue to only find out it was a simple parameter name.

You may go through this tutorial completely confused. I provide checkpoints along the way so that you can copy and paste scripts in their entirety to better understand where you miss something.

Concepts may not solidify either the first time around. I try my best to reduce that burden.
:::

## What This Tutorial Skips

One area of D3 relates to its data transformation functions, which are impressive and robust. I won't have time to cover this in this tutorial and I personally stick to good ol' `tidyverse` in R for most data prep.

The one thing you should do though is rely on `list` to organize your data. Note though that this data is not limited to the data being presented, but other data points, such as annotations.

::: callout-tip
## ChatGPT is quite good!

I actually have better luck asking ChatGPT questions than I do consulting with D3 documentation. I believe the reason is ChatGPT has to know how to crawl the internet, so HTML, CSS, and JavaScript are skills it learned quite well.

I also find that ChatGPT is better at D3 than R and R Shiny.

That said, it is still better when asking narrow questions.
:::

## Recommended: Create a Mockup

Normally, I think it overkill to create a mockup of a single data visualization. However, it's actually a good idea when it comes to D3.

One simple reason is that it helps keep you inspired, since you won't see the fruit of your work right away.

The second reason is that D3 requires such minute coding that it doesn't allow for as much iteration, especially when it comes to aesthetics and interactivity.

We'll be building something simple today, so the mockup's primary benefit will be for us to pick colors and aesthetics up front.

(show mockup)

## Create R Script

Create an R script called `scrap.R`. This is where we'll run evolving R code as we proceed through the tutorial.

Place the following at the top:

```{r, eval = FALSE}
library(devtools)
library(tidyverse)
library(jsonlite)

```

## Our Data Set

We'll be using the `freeStateData` package's `us_treasury_data_1890s` data set for this visualization. This package (built by yours truly) contains economic history data (for now). I periodically update it with data I find interesting. (Feel free to use it for other projects too).

```{r, eval = FALSE}
devtools::install_github("https://github.com/Free-State-Analytics/freeStateData")
```

Place and run the following in your `scrap.R` file.

```{r}
library(freeStateData)
data("us_treasury_data_1890s")
```

You can run `?us_treasury_data_1890s` to see more information on this data set.

We're gonna rename this to `dGold` for now and reduce the data to something simpler.

```{r}
dGold <- us_treasury_data_1890s %>%
  filter(as.Date(year_month) >= as.Date("1892-11-01"),
         as.Date(year_month) <= as.Date("1893-12-31")) %>%
  select("year_month",
         "gold_certificates_in_treasury_cash") %>%
  rename(
    date = year_month,
    gold_in_cash = gold_certificates_in_treasury_cash)

head(dGold)
```

## Transforming to JSON

R data.frame is not what we need for D3. D3 relies on JSON structures.

Use `jsonlite::toJSON` to transform `dGold`. Assign the JSON file the name `jGold`.

```{r}
jGold <- jsonlite::toJSON(dGold)
jGold
```

## Create Primary Plot JavaScript Function

In your directory...

1.  Create a folder called `D3`
2.  Using Posit Cloud's "D3 Script" example, save a script called `plot_main.js` within the `D3/` directory

You should see it render in your Viewer immediately.

::: callout-important
## Why \`plot_main.js\`?

The length of code in a single D3 data visualization will get overwhelming fast. This makes it much more difficult to trouble shoot.

For that reason, we have a single script that will contain more specialized scripts in the future.
:::

## Create Render Plot R Function

In `scrap.R`, add the following:

```{r, eval = FALSE}
r2d3::r2d3(
  data = c(0.3, 0.6, 0.8, 0.95, 0.40, 0.20),
  script = "D3/plot_main.js"
)

```

```{r, echo = FALSE}
r2d3::r2d3(
  data = c(0.3, 0.6, 0.8, 0.95, 0.40, 0.20),
  script = "/cloud/project/D3/plot_main.js"
)
```

::: callout-important
## What is svg?

If you notice, our `plot_main.js` currently references an object called `svg`.

`r2d3` generates an svg div in HTML by default. Any further code we write appends to this div or modifies it.

The wiki definition for svg is: Scalable Vector Graphics is an XML-based vector image format for defining two-dimensional graphics, having support for interactivity and animation.
:::

## Checkpoint!

We're going to provide check points frequently now. Things are about to get super hard! Check to make sure your `scrap.R` file matches below and that the D3 visualizatoin renders to your Viewer.

```{r, eval = FALSE}
library(devtools)
library(tidyverse)
library(jsonlite)
library(freeStateData)
data("us_treasury_data_1890s")

dGold <- us_treasury_data_1890s %>%
  select("year_month",
         "gold_certificates_in_treasury_cash") %>%
  rename(
    date = year_month,
    gold_in_cash = gold_certificates_in_treasury_cash)

jGold <- jsonlite::toJSON(dGold)
jGold

r2d3(
  data = c(0.3, 0.6, 0.8, 0.95, 0.40, 0.20),
  script = "D3/plot_main.js"
)
```

## Swap Out Data

Building a D3 visualizations means building pieces that won't necessarily appear yet. Have faith in the process, but also follow instructions closely. If it helps, copy and paste the code you see directly from this tutorial.

First, let's replace our `data` parameter in `r2d3` with `jGold` in our `scrap.R` file:

```{r, eval = FALSE}
r2d3(
  data = jGold,
  script = "D3/plot_main.js"
)
```

This will make the rendering unavailable for the time being.

## Creating Y-Axis

Now that we're feeding proper data to our D3 plot, let's add the axises. We're going to start with the y-axis, because the formatting is easier to understand and it'll help ease us into the key concepts.

There are actually four stages to producing an axis:

1.  Define the min and max value for your axis
2.  Define the dimensions of the axis
3.  Define aesthetics of the axis
4.  Append axis to your svg

The variables or "bindings" in one stage are referenced in the next.

That's a lot of work for just one axis, right?

And each steps has lots of fine little nuances that if you do wrong, nothing works!

### Define Min and Max Value for Axis

We're going to hard code the min and max vlaue for our axis in this tutorial. Looking at `max(dGold$gold_in_cash)`, we see that the max value is `37721280`. We're going to round up to `37500000` for this tutorial, but you can use D3's robust data prep functions to dynamically select the max value.

Within `plot_main.js`, we're going to delete everything and add the following:

```{js, eval = FALSE}
// Stage One: Define min and max values of interest
const y_min = 0;
const y_max = 37500000;
```

`const` is a "binding" in JavaScript that makes it easier to pass around values, much in the same way an object name does in R.

### Define Dimensions of the Axis

We're going to create another binding which defines the dimensions the axis should follow. We'll call it `y_dimension`.

We'll have to define the type of axis we're defining. In this example, we are looking at numeric data with a linear scale. So we'll use `d3.scaleLinear`.

You can see all the options for D3's scales here **provide link**

In `plot_main.js`, add the following:

```{js, eval = FALSE}
// Stage Two: Define dimensions
const y_dimension = d3.scaleLinear();
```

That doesn't do anything though. We have to define the dimensions, which rely crucially on two key concepts mentioned at the start of the tutorial: domain and range.

**Domain** is the dimension in relation to the actual data (i.e., the min value and the max value of interest). We pass a JavaScript array to the `.domain()` function.

```{js, eval = FALSE}
// Stage Two: Define dimensions
const y_dimension = d3.scaleLinear()
  .domain([y_min, y_max])
```

As you can tell, an [array in JavaScript](https://eloquentjavascript.net/04_data.html#h-k6fyJHbpdU) is not like an array in R.

**Range** is the dimension in relation to the SVG (i.e., how far does the axis traverse across the overall image).

We will pass an array `[0, height]` through `.range()`:

```{js, eval = FALSE}
// Stage Two: Define dimensions
const y_dimension = d3.scaleLinear()
  .domain([y_min, y_max])
  .range([0, height]);
```

`height` is a default variable added to your D3 script via `r2d3`. It basically encompasses the entire view port available.

Your complete `plot_main.js` up to this point should look like the following:

```{js, eval = FALSE}
// Stage One: Define min and max values of interest
const y_min = 0;
const y_max = 37500000;

// Stage Two: Define dimensions
const y_dimension = d3.scaleLinear()
  .domain([y_min, y_max])
  .range([0, height]);
```

Keep in mind, you won't see anything yet in your Viewer window.

### Define Aesthetics

`y_dimension` defines how the data will place itself in relation to the SVG. It does not really define how axis itself will appear. That is what our next binding `y_aesthetics` will do.

We'll pass `y_dimension` as a param to D3's `axisLeft()`. This first defines that we want the axis to be treated as left axis, which passes defaults to the labels of interest.

You can read more about axises here: **provide link**

In `plot_main.js`, add the following at the bottom:

```{js, eval = FALSE}
// Stage Three: Define aesthetics
const y_aesthetic = d3.axisLeft(y_dimension);
```

We will be sprucing `y_aesthetic` up further later, but for now, we're going to rely on defaults.

### Append Axis to SVG

We built bindings that will inform D3 what we want to see in our axis. However, we haven't updated our SVG yet to use this information.

In `plot_main.js`, add the following to the bottom:

```{js, eval = FALSE}
// Stage Four: Append to SVG
svg.append("g")
  .call(y_aesthetic);
```

This appends a `g` div to your `svg`. You then call your `y_aesthetic` binding, which references your `y_dimension` binding, which references your `y_min` and `y_max` binding, to inform the new `g` what it should look like.

Your complete `plot_main.js` script should look like:

```{js, eval = FALSE}
// Stage One: Define min and max values of interest
const y_min = 0;
const y_max = 37500000;

// Stage Two: Define dimensions
const y_dimension = d3.scaleLinear()
  .domain([y_min, y_max])
  .range([0, height]);
 
// Stage Three: Define aesthetics
const y_aesthetic = d3.axisLeft(y_dimension);

// Stage Four: Append to SVG
svg.append("g")
  .call(y_aesthetic);
```

Now run the following:

```{r, eval = FALSE}
r2d3::r2d3(
  data = jGold,
  script = "D3/plot_main.js"
)
```

### Adding Margin

If you notice, our line is at the far edge. There are actual labels on our axis, but we can't see them.

Let's move our axis to the right by adding some margin space. We can do this by modify Stage Four's `svg.append()` function and adding a CSS attribute that says "transform" by nudging ***100 pixels to the right***.ISthisright?

```{js, eval = FALSE}
// Stage Four: Append to SVG
svg.append("g")
  .attr("transform", `translate(100, 0)`)
  .call(y_aesthetic);
```

### Flipping Our Axis

Now re-run your `r2d3` script in `scrap.R`. Notice anything funny?

```{r, eval = FALSE}
r2d3::r2d3(
  data = jGold,
  script = "D3/plot_main.js"
)
```

```{r, echo = FALSE}
r2d3::r2d3(
  data = jGold,
  script = "/cloud/project/D3/plot_main.js"
)
```

This is how touchy little arguments are with regards to D3. What happened is that we mapped our range `[0, height]` to our domain `[y_min, y_max]` by saying that `0` corresponds to `y_min`. Really, we want `0` to correspond to `y_max`.

We can modify `y_dimension` to account for this:

```{js, echo = FALSE}
// Stage Two: Define dimensions
const y_dimension = d3.scaleLinear()
  .domain([y_min, y_max])
  .range([height, 0]);
```

And our complete `plot_main.js` script is like so:

```{js, echo = FALSE}
// Stage One: Define min and max values of interest
const y_min = 0;
const y_max = 37500000;

// Stage Two: Define dimensions
const y_dimension = d3.scaleLinear()
  .domain([y_min, y_max])
  .range([height, 0]);
 
// Stage Three: Define aesthetics
const y_aesthetic = d3.axisLeft(y_dimension);

// Stage Four: Append to SVG
svg.append("g")
  .attr("transform", `translate(100, 0)`)
  .call(y_aesthetic);
```

## Creating X-Axis

We have one axis done! Quite a bit of work, right? Now we'll have to add the x-axis.

Once again, we'll have four stages:

1.  Define the min and max value for your axis
2.  Define the dimensions of the axis
3.  Define aesthetics of the axis
4.  Append axis to your svg

### Define Min and Max Value for Axis

Much like the y-axis, we want to hardcode our values for now. Unlike the y-axis, we'll pick specific values rather than select the values found in the data set.

We want our min date to be `1892-11-01` and max date to be `1893-12-31`.

However, we'll have to translate those values to be something JavaScript can understand. (This is a good example of ChatGPT being helpful.)

Within `plot_main.js`, place the following near the bottom of the script:

```{js, eval = FALSE}
// Stage One: Define min and max values of interest  
const x_min = new Date("1892-11-01");
const x_max = new Date("1893-12-31");  
```

### Define Dimensions of the Axis

Much like before, we're gonna create a binding called `x_dimension` to define the dimensiosn of our x-axis. Unlike before, we have to use a different scale. Since this relates to datetimes, we'll use `d3.scaleTime`. You can see all the options for D3's scales here **provide link**

In `plot_main.js`, add the following:

```{js, eval = FALSE}
// Stage Two: Define dimensions
const x_dimension = d3.scaleTime();
```

We'll define our `.domain` in a similar way as before:

```{js, eval = FALSE}
// Stage Two: Define dimensions
const x_dimension = d3.scaleLinear()
  .domain([x_min, x_max])
```

And our range using `width` instead. (Notice that `width` needs to correspond to `x_max`.

```{js, eval = FALSE}
// Stage Two: Define dimensions
const x_dimension = d3.scaleLinear()
  .domain([x_min, x_max])
  .range([0, width]);
```

`width` is a default variable added to your D3 script via `r2d3`, much like `height`. It covers the width of the viewport and makes D3 data visualizations dynamic when they resize.

### Define Aesthetics

Our next binding `x_aesthetic` will be similar to before, only we will use `axisBottom`.

You can read more about axises here: **provide link**

In `plot_main.js`, add the following at the bottom:

```{js, eval = FALSE}
// Stage Three: Define aesthetics
const x_aesthetic = d3.axisBottom(x)
```

We will be sprucing `y_aesthetic` up further later, but for now, we're going to rely on defaults.

### Append Axis to SVG

Finally, we need to append our SVG.

```{js, eval = FALSE}
// Stage Four: Append to SVG
svg.append("g")
  .call(x_aesthetic);
```

Our complete `plot_main.js` script should look like this:

```{js, eval = FALSE}
// Stage One: Define min and max values of interest
const y_min = 0;
const y_max = 37500000;

// Stage Two: Define dimensions
const y_dimension = d3.scaleLinear()
  .domain([y_min, y_max])
  .range([height, 0]);
 
// Stage Three: Define aesthetics
const y_aesthetic = d3.axisLeft(y_dimension);

// Stage Four: Append to SVG
svg.append("g")
  .attr("transform", `translate(100, 0)`)
  .call(y_aesthetic);
  
// Stage One: Define min and max values of interest  
const x_min = new Date("1892-11-01");
const x_max = new Date("1893-12-31");  

// Stage Two: Define dimensions
const x_dimension = d3.scaleLinear()
  .domain([x_min, x_max])
  .range([0, width]);
  
// Stage Three: Define aesthetics
const x_aesthetic = d3.axisBottom(x_dimension)
  
// Stage Four: Append to SVG
svg.append("g")
  .call(x_aesthetic);
```

### There Is a Lot Wrong Here

When you re-run your `scrap.R` file, we find a lot wrong with the rendering.

Much of this has to do with margins. Some of it has to do with the values used in `x_aesthetic` and `y_aesthetic`.

Also, our script is getting long. We'll need to slim that down.

We're gonna tackle the margins for now.

## Define and Pass Margins

**Margins** are a key concept in D3 that will show up a lot. Most tutorials you'll find have margins as a default value. And it's important to define them in once place because you use them everywhere!

For that reason, it's best to define them in one place.

At the top of `plot_main.js`, add the following:

```{js, eval = FALSE}
const margin = {top: 100, bottom: 100, right: 100, left: 100}
```

Now, we need to adjust the x- and y-axis to use these margins.

Let's line up the left margin first.

### Modify X- and Y-Axis to Use `margin.left`

Modify the "transform" attribute for our `g` div for the y-axis like so:

```{js, eval = FALSE}
// Stage Four: Append to SVG
svg.append("g")
  .attr("transform", `translate(${margin.left}, 0)`)
  .call(y_aesthetic);
```

And now modify `x_dimension` to do the same:

```{js, eval = FALSE}
// Stage Two: Define dimensions
const x_dimension = d3.scaleLinear()
  .domain([x_min, x_max])
  .range([margin.left, width]);
```

::: callout-important
## Why did we add \`margin.left\` in differnet places for x- and y-axis?

You may have noticed that we updated the `range()` for the x-axis to use `margin.left`, but updated the attribute of `g` div for our y-axis. Why?

Well, it has to do with what these are working on. `y_dimension` focused on defining how our future bar graph will expand and contract vertically. That means it doesn't need to think about where it goes on the x-axis. However, we want to change its x-axis position. We do that by changing where `g` is placed.

Oppositely, `x_dimension` is concerned with how our future bar graph will interpret data on a horizontal scale. `margin.left` is crucial for determining that placement. So we have to use that information in the `range`.
:::

### Aside: Modify X-Axis to Be on Bottom

This isn't quite rleated to the margins, but now that we better understand how attribute rela

```{js, eval = FALSE}
// Stage Four: Append to SVG
svg.append("g")
  .attr("transform", `translate(0, ${height})`)
  .call(x_aesthetic);
```

When you run this though, our x-axis disappears entirely! We have to add our other margins.

### Modify X- and Y-Axis to Use Other Margins

asdga

```{js, eval = FALSE}
// Stage Two: Define dimensions
const y_dimension = d3.scaleLinear()
  .domain([y_min, y_max])
  .range([height - margin.bottom, margin.top]);
```

asdgasdg

```{js, eval = FALSE}
// Stage Four: Append to SVG
svg.append("g")
  .attr("transform", `translate(0, ${height - margin.bottom})`)
  .call(x_aesthetic);
```

asdgag

```{js, eval = FALSE}
// Stage Two: Define dimensions
const x_dimension = d3.scaleLinear()
  .domain([x_min, x_max])
  .range([margin.left, width - margin.right]);
```

Our complete \``` plot_main.js` `` script so far should look like:

```{js, eval = FALSE}
const margin = {top: 100, bottom: 100, right: 100, left: 100}

// Stage One: Define min and max values of interest
const y_min = 0;
const y_max = 37500000;

// Stage Two: Define dimensions
const y_dimension = d3.scaleLinear()
  .domain([y_min, y_max])
  .range([height - margin.bottom, margin.top]);
 
// Stage Three: Define aesthetics
const y_aesthetic = d3.axisLeft(y_dimension);

// Stage Four: Append to SVG
svg.append("g")
  .attr("transform", `translate(${margin.left}, 0)`)
  .call(y_aesthetic);
  
  
// Stage One: Define min and max values of interest  
const x_min = new Date("1892-11-01");
const x_max = new Date("1893-12-31");  

// Stage Two: Define dimensions
const x_dimension = d3.scaleLinear()
  .domain([x_min, x_max])
  .range([margin.left, width - margin.right]);
  
// Stage Three: Define aesthetics
const x_aesthetic = d3.axisBottom(x_dimension)
  
// Stage Four: Append to SVG
svg.append("g")
  .attr("transform", `translate(0, ${height - margin.bottom})`)
  .call(x_aesthetic);
```

Still want to learn D3? :)

## Begin to Modularize

Our script is getting longer. It's getting more confusing. Thankfully, we can start to modularize it. No, we're not gonna have to learn namespacing like we do in R Shiny, but we are gonna use a similar concept and make everythign smaller.

We're gonna move our x- and y-axis scripts into indiviual functions out of `plot_main.js`. We're gonna call them:

1.  `plot_x_axis.js`
2.  `plot_y_axis.js`

We're also gonna modify our `r2d3` script to use those new files and create a callable function to make it easier to render.

### Create `plot_x_axis.js`

agak;g

```{js, eval = FALSE}
function plot_x_axis(svg, margin) {
  // Stage One: Define min and max values of interest  
  const x_min = new Date("1892-11-01");
  const x_max = new Date("1893-12-31");  
  
  // Stage Two: Define dimensions
  const x_dimension = d3.scaleLinear()
    .domain([x_min, x_max])
    .range([margin.left, width - margin.right]);
    
  // Stage Three: Define aesthetics
  const x_aesthetic = d3.axisBottom(x_dimension)
    
  // Stage Four: Append to SVG
  svg.append("g")
    .attr("transform", `translate(0, ${height - margin.bottom})`)
    .call(x_aesthetic);
}
```

### Create `plot_y_axis.js`

agak;g

```{js, eval = FALSE}
function plot_y_axis(svg, margin) {
  
  // Stage One: Define min and max values of interest
  const y_min = 0;
  const y_max = 37500000;
  
  // Stage Two: Define dimensions
  const y_dimension = d3.scaleLinear()
    .domain([y_min, y_max])
    .range([height - margin.bottom, margin.top]);
   
  // Stage Three: Define aesthetics
  const y_aesthetic = d3.axisLeft(y_dimension);
  
  // Stage Four: Append to SVG
  svg.append("g")
    .attr("transform", `translate(${margin.left}, 0)`)
    .call(y_aesthetic);
}
```

### Modify `plot_main.js`

And here is updated `plot_main.js`:

```{js, eval = FALSE}
const margin = {top: 100, bottom: 100, right: 100, left: 100};

// Create x- and y-axis
plot_y_axis(svg, margin);
plot_x_axis(svg, margin);
```

We'll have to update our `r2d3` script to use these additional files:

```{r, eval = FALSE}
r2d3::r2d3(
  data = jGold,
  script = c("D3/plot_main.js", "D3/plot_x_axis.js", "D3/plot_y_axis.js")
)
```

::: callout-note
## You don't have to define svg and margin

Unlike R, you don't actually need to define svg and margin as parameters. JavaScript will treat them universally. However, I believe it's best to be explicit in what you're doing, mostly for readability sake.
:::

### Create `plot_gold_viz`

It is getting tedious to re-run `r2d3` over and over again. And it'll get to be even more tedious as we add more `.js` files.

We can made a single R function that both searches for all .js files and produces the data viz. I'm not going to define this too much since we're primarily focused on learning D3.

Save the following in R/`plot_gold_viz.R`

```{r, eval = FALSE}

plot_gold_viz <- function(jGold, directory_path = "Cloud/project/D3") {
  file_list <- list.files(
    path = directory_path, 
    full.names = TRUE)
  
  js_scripts <- file_list[grepl(".js",file_list)]

  r2d3::r2d3(
    data = jGold,
    script = paste0("D3/",js_scripts)
  )
  
}
```

Now update your `scrap.R` file:

```{r, eval = FALSE}
library(devtools)
library(tidyverse)
library(jsonlite)
library(freeStateData)
data("us_treasury_data_1890s")

dGold <- us_treasury_data_1890s %>%
  select("year_month",
         "gold_certificates_in_treasury_cash") %>%
  rename(
    date = year_month,
    gold_in_cash = gold_certificates_in_treasury_cash)

jGold <- jsonlite::toJSON(dGold)

source("R/plot_gold_viz.R")

plot_gold_viz()
```

Now all you have to do is run `plot_gold_viz()` and your D3 viz will take any additional `.js` files required.

## Improve Axis Tick Labels

Right now, neither of our axis tick labels look very good. The dates don't look like dates at all. The numbers on the right are too big.

Being largely an aesthetic consideration, unrelated to the actual scaling of data to size of the axis and the SVG, we are naturally going to update `y_aesthetic` and `x_aesthetic`.

### Updating X-Axis Tick Label

The x-axis needs a time formatter to create a biding with teh appropriate labels. <https://d3js.org/d3-time-format>

We then have to update the tick's format with this formatter binding. <https://d3js.org/d3-axis#axis_tickFormat>

```{js, eval = FALSE}
// Stage Three: Define aesthetics
const format_date = d3.utcFormat("%y %b");

const x_aesthetic = d3.axisBottom(x_dimension)
  .tickFormat(format_date);
```

### Updating Y-Axis Tick Label

The y-axis does not need to use the specialized `utcFormat` function. It'll use D3's `format` to first turn the label into a currency and then apply that binding using `tickFormat()`.

This is made useless by the fact that we want to present our numbers at "M". So I find it easier to simply attach the "\$" and "M" directly to it.

```{js, eval = FALSE}
// Stage Three: Define aesthetics
const format_currency = d3.format("($")

const y_aesthetic = d3.axisLeft(y_dimension)
  .tickFormat(d => format_currency(d / 1000000) + "M");
  
// Alternative
const y_aesthetic = d3.axisLeft(y_dimension)
  .tickFormat(d => "$" + (d / 1000000) + "M");
```

## Adding Shapes

D3 visualizations rely heavily on shapes for most standard data visualizations. Shapes are drawings that take instructions from the data you pass it. Since we defined the margins, domain, and range with our current functions, they know where to place themselves in relation to the x and y axis.

<https://d3js.org/d3-shape>

If you think there is perfect consistency in how these shapes are produced, prepare to be semi-disappointed.

## Create Bar Shape

We're gonna start with a bar graph. In your `D3/` directory, create `plot_bar.js`.

```{js, eval = FALSE}
function plot_bar(svg, data, x_dimension, y_dimension) {

}
```

You may notice that we have four parameters to pass to this JS function. Two look quite familiar.

In order for us to simply pass those two, we need to turn them into bindings that canb e passed as parameters.

### Modularize `x_dimension` and `y_dimension`

Unfortunately, `x_dimension` and `y_dimension` are not yet available. We could modify `plot_axis_y` and `plot_x_axis` to return them. However, this may confused the purpose those functions in our `plot_main.js` script.

So let's separate those out!

Create two additional files in your `D3/` directory.

One called `plot_x_dimension.js` ...

```{js, eval = FALSE}
function plot_x_dimension() {
  // Stage One: Define min and max values of interest  
  const x_min = new Date("1892-11-01");
  const x_max = new Date("1893-12-31");  
  
  // Stage Two: Define dimensions
  const x_dimension = d3.scaleLinear()
    .domain([x_min, x_max])
    .range([margin.left, width - margin.right]);
    
  return x_dimension;
}
```

... and the other `plot_y_dimension.js`.

```{js, eval = FALSE}
function plot_y_dimension() {
  // Stage One: Define min and max values of interest
  const y_min = 0;
  const y_max = 37500000;
  
  // Stage Two: Define dimensions
  const y_dimension = d3.scaleLinear()
    .domain([y_min, y_max])
    .range([height - margin.bottom, margin.top]);
    
  return y_dimension;
}
```

We'll have to modify `plot_main.js` to use define the binding.

```{js, eval = FALSE}
const margin = {top: 100, bottom: 100, right: 100, left: 100};

// Create x and y dimensions
const x_dimension = plot_x_dimension(svg, margin)
const y_dimension = plot_y_dimension(svg, margin)

// Create x- and y-axis
plot_x_axis(svg, margin, x_dimension);
plot_y_axis(svg, margin, y_dimension);

// Add line
plot_line(svg, data, x_dimension, y_dimension);
```

We'll need to modify our `plot_x_axis` and `plot_y_axis` to use this as a parameter.

Here is `plot_x_axis.js`...

```{js, eval = FALSE}
function plot_x_axis(svg, margin, x_dimension) {
  // Stage Three: Define aesthetics
  const format_date = d3.utcFormat("%y %b");
  
  const x_aesthetic = d3.axisBottom(x_dimension)
    .tickFormat(format_date);
    
  // Stage Four: Append to SVG
  svg.append("g")
    .attr("transform", `translate(0, ${height - margin.bottom})`)
    .call(x_aesthetic);
    
  return x_dimension;
}
```

...and here is `plot_y_axis.js`

```{js, eval = FALSE}
function plot_y_axis(svg, margin, y_dimension) {
  
  // Stage Three: Define aesthetics
  const y_aesthetic = d3.axisLeft(y_dimension)
    .tickFormat(d => "$" + (d / 1000000) + "M");
  
  // Stage Four: Append to SVG
  svg.append("g")
    .attr("transform", `translate(${margin.left}, 0)`)
    .call(y_aesthetic);
  
}
```

Your `plot_main.js` should now look like this.

```{js, eval = FALSE}
const margin = {top: 100, bottom: 100, right: 100, left: 100};

// Create x and y dimensions
const x_dimension = plot_x_dimension(margin)
const y_dimension = plot_y_dimension(margin)

// Create x- and y-axis
plot_x_axis(svg, margin, x_dimension);
plot_y_axis(svg, margin, y_dimension);

// Add bar
plot_bar(svg, margin, data, x_dimension, y_dimension)
```

### Back to `plot_bar.js`

Back to our empty `plot_bar.js` function. This is where D3 begins to require counter-intuitive scripting.

First, we `selectAll("gold-bar")`, which looks for any tag with the name of "gold-bar."

No such tag exists yet, but that's okay.

```{js, eval = FALSE}
function plot_bar(svg, margin, data, x_dimension, y_dimension) {
  
  svg.selectAll("gold-bar")

}
```

Next, we "map" our data to the selection of tag named "gold-bar," despite no such tag existing.

```{js, eval = FALSE}
function plot_bar(svg, margin, data, x_dimension, y_dimension) {
  
  svg.selectAll("gold-bar")
    .data(data)
  
}
```

Now, the data knows that it has nothing to map itself to, because again, "gold-bar" does nto exist.

So we need to inform data that we're going to pass it something new to map itself to. We use `enter()` to start that process.

```{js, eval = FALSE}
function plot_bar(svg, margin, data, x_dimension, y_dimension) {
  
  svg.selectAll("gold-bar")
    .data(data)
    .enter()
  
}
```

But what will we map it to? Rectangles! Which is what a bar graph really is made of.

```{js, eval = FALSE}
function plot_bar(svg, margin, data, x_dimension, y_dimension) {
  
  svg.selectAll("gold-bar")
    .data(data)
    .enter()
    .append("rect")
  
}
```

A rectangle's placement is based on each `date` (x-axis) and `gold_in_cash` (y-axis). So we need to pass instructions on how to use those data points appropriately.

```{js, eval = FALSE}
function plot_bar(svg, margin, data, x_dimension, y_dimension) {
  
  svg.selectAll("gold-bar")
    .data(data)
    .enter()
    .append("rect")
    .attr("x", d => x_dimension(new Date(d.date)))
    .attr("y", d => y_dimension(d.gold_in_cash))  
    
}
```

That does not create the shape though. It only defines the starting point!

We need to inform D3 how wide and how tall (technically, it's how deep) the chart should be drawn.

```{js, eval = FALSE}
function plot_bar(svg, margin, data, x_dimension, y_dimension) {
  
  svg.selectAll("gold-bar")
    .data(data)
    .enter()
    .append("rect")
    .attr("x", d => x_dimension(new Date(d.date)))
    .attr("y", d => y_dimension(d.gold_in_cash))  
    .attr("width", 20)
    .attr("height", d => height - margin.bottom - y_dimension(d.gold_in_cash));  
    
}
```

Just for fun, trying commenting out the line `.attr("y", d => .....`. Notice how your plots start at the top?

## Create Headings

If you recall our mockup, we had a heading and a subheading.

(show mockup)

Let's go ahead and add those. Yes, just like before, we'll make a function.

In your `D3/` directory, create the file `plot_header.js`.

```{js, eval = FALSE}
function plot_header(svg, margin) {
  
  svg.append("text")
    .attr("x", margin.left)
    .attr("y", margin.top * .15)
    .text("U.S. Gold Certificates in Treasury Cash")
    
  svg.append("text")
    .attr("x", margin.left)
    .attr("y", margin.top * .50)
    .text("From November 1892 until December 1893")
  
}
```

## Beautification of Our Visualization

Aesthetically... our D3 visualization isn't very pretty. That's ironic, because what is usually so cool about D3 is the user-experience for the audience.

But that UX usually comes from the precision programming, which requires all the functional aspects to be determined first.

Now, we can work on making our visualization LOOK more like our mockup.

You may have noticed, we can apply `style` directly to our various components. However, this doesn't make it easy to manage across functions. Particularly as we start to produce new visualizations using the same items.

This is where a `.css` style sheet comes in handy!

## Add Color to `plot_bar.js`

As you recall from our mockup, we actually have two colors to add: gold and grey.

Let's first see how this works out.

Modify `plot_bar.js` to include some style arguments. Pay close attention to where I placed them.

```{js, eval = FALSE}
function plot_bar(svg, margin, data, x_dimension, y_dimension) {

  svg.selectAll("gold-bar")
    .data(data)
    .enter()
    .append("rect")
    .style("fill", "#AC882A")
    .style("stroke", "#373735")
    .attr("x", d => x_dimension(new Date(d.date)))
    .attr("y", d => y_dimension(d.gold_in_cash))  
    .attr("width", 20)
    .attr("height", d => height - margin.bottom - y_dimension(d.gold_in_cash));

}
```

## Add Color to Headers, Axis, Label - Part One

Now we want to update the color on our axis, headers, etc. to use the dark gray defined in our mockup.

We could easily add style arguments to the `plot_header.js`, like so:

```{js, eval = FALSE}
function plot_header(svg, margin) {
  
  svg.append("text")
    .style("fill", "#373735")
    .attr("x", margin.left)
    .attr("y", margin.top * .15)
    .text("U.S. Gold Certificates in Treasury Cash")
  
  svg.append("text")
    .style("fill", "#373735")
    .attr("x", margin.left)
    .attr("y", margin.top * .50)
    .text("From November 1892 until December 1893")
  
}
```

However, this is starting to get tedious. And it doesn't make it easy to update. For example, what if we wanted to play around with colors? We'd have to update each and every style block.

Let's come back to this and build us a .css file.

## Create a `.css` File

In your `D3/` directory, create the file `style.css`.

Next, we're gonna define a class for our axis and headers.

```{css, eval = FALSE}
.header {
  fill: #373735;
}

.subheader {
  fill: #373735;
}

.axis {
  fill: #373735;
}
```

However, that won't update the D3 data viz on its own.

Next, we're gonna modify `plot_gold_viz` to use this CSS.

```{r, eval = FALSE}
plot_gold_viz <- function(jGold, directory_path = "/cloud/project/D3") {
  
  file_list <- list.files(
    path = directory_path, 
    full.names = TRUE)
  
  js_scripts <- file_list[grepl(".js",file_list)]

  r2d3::r2d3(
    data = jGold,
    script = js_scripts,
    css = paste0(directory_path, "/style.css")
  )
  
} 
```

Next, we're gonna update the following functions:

```{js, eval = FALSE}
function plot_header(svg, margin) {
  
  svg.append("text")
    .attr("class", "header")
    .attr("x", margin.left)
    .attr("y", margin.top * .15)
    .text("U.S. Gold Certificates in Treasury Cash")
  
  svg.append("text")
    .attr("class", "subheader")
    .attr("x", margin.left)
    .attr("y", margin.top * .50)
    .text("From November 1892 until December 1893")
    
}

function plot_x_axis(svg, margin, x_dimension) {
  // Stage Three: Define aesthetics
  const format_date = d3.utcFormat("%y %b");
  
  const x_aesthetic = d3.axisBottom(x_dimension)
    .tickFormat(format_date);
    
  // Stage Four: Append to SVG
  svg.append("g")
    .attr("transform", `translate(0, ${height - margin.bottom})`)
    .attr("class", "axis")
    .call(x_aesthetic);
    
  return x_dimension;
}

function plot_y_axis(svg, margin, y_dimension) {
  
  // Stage Three: Define aesthetics
  const y_aesthetic = d3.axisLeft(y_dimension)
    .tickFormat(d => "$" + (d / 1000000) + "M");
  
  // Stage Four: Append to SVG
  svg.append("g")
    .attr("transform", `translate(${margin.left}, 0)`)
    .attr("class", "axis")
    .call(y_aesthetic);
  
}
```

Let's also move our style cod efor `plot_bar.js` to css.

```{css, eval = FALSE}
.gold-bar {
  fill: #AC882A;
}
```

Next, we're gonna modify `plot_bar.js`. Notice where I place it! Tha'ts to prevent from black from initially appearign before the gold.

```{r, eval = FALSE}
function plot_bar(svg, margin, data, x_dimension, y_dimension) {

  svg.selectAll("gold-bar")
    .data(data)
    .enter()
    .append("rect")
    .attr("class", "gold-bar")
    .attr("x", d => x_dimension(new Date(d.date)))
    .attr("y", d => y_dimension(d.gold_in_cash))  
    .attr("width", 20)
    .attr("height", d => height - margin.bottom - y_dimension(d.gold_in_cash));
    
}
```

## Changing Axis and Text Colors

Now, we need to use the dark grey color for our axis and text.

Since this

\`\`

## Changing Fonts

## Create Line Shape

### Back to `plot_line.js`

Back to our empty `plot_line.js` function. We are appending a visual element to our SVG. So we'll start with that...

```{js, eval = FALSE}
function plot_line(svg, data, x_dimension, y_dimension) {
  
  svg.append("path")
  
}
```

### Provide Data for Your Shape

We'll need to inform the new path the data it will use to create its shape.

```{js, eval = FALSE}
function plot_line(svg, data, x_dimension, y_dimension) {
  
  svg.append("path")
    .datum(data)

}
```

### Add Line

How

```{js, eval = FALSE}
function plot_line(svg, data, x_dimension, y_dimension) {
  
  svg.append("path")
    .datum(data)
    .attr("d", d3.line()
      .x(function(d) {return x_dimension(new Date(d.date))})
      .y(function(d) {return y_dimension(d.gold_in_cash)})
    );

}
```

### Add Style Arguments

What is supposed to be a line on our plot look like a black void of despair. Thankfully, SVG can respond to CSS style arguments, much in the same way any HTML tag can.

```{js, eval = FALSE}
function plot_line(svg, data, x_dimension, y_dimension) {
  
  svg.append("path")
    .datum(data)
    .attr("d", d3.line()
      .x(function(d) {return x_dimension(new Date(d.date))})
      .y(function(d) {return y_dimension(d.gold_in_cash)})
    )
    .style("stroke", "blue")
    .style("stroke-width", 1.5)
    .style("fill", "none");

}
```

There will be different ways we manage the style arguemnts later. For now this will do.

## Create Dots

Our mockup showed that we had dots to add to the lines. The good news is we have everything in place to do this!

We're going to create a new file called `plot_dots.js` to place in our `D3/` directory.

```{js, eval = FALSE}
function plot_dot(svg, data, x_dimension, y_dimension) {
  svg.selectAll("circle") 
    .data(data)
    .enter()
    .append("circle")
    .attr("cx", function (d) {return x_dimension(new Date(d.date))})
    .attr("cy", function (d) { return y_dimension(d.gold_in_cash); }) 
    .style("r", 5) 
    .style("fill", "green"); 
}

```

::: callout-important
## data vs. datum

asgag

`datum` and `data().enter()`
:::
